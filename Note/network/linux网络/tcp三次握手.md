![[tcp三次握手.png]]

1. 服务器 listen 时，tcp 状态由 CLOSE 变为 LISTEN，并计算了全/半连接队列的长度，还申请了相关内存并初始化。这里会建立一个 “监听 socket”，用于监听客户端连接
> [!info] 全连接队列和半连接队列
>  - 全连接队列：又称 Accept 队列（底层结构：双向链表，先进先出），包含了服务端所有完成了三次握手，但是还未被应用调用 accept 取走的连接队列。此时的 socket 处于 ESTABLISHED 状态。如果 accept 阻塞不被调用，那么很快全连接就可以被占满，此时再来客户端连接将超时，server 会舍弃 client 发送过来的 SYN，客户端一直重试，最终超时断开。
>  - 半连接队列：又称 SNY 队列（底层结构：Hash表，易于查找），服务端收到客户端的 SYN 包，回复 SYN+ACK 但是还没有收到客户端 ACK 情况下，会将连接信息放入半连接队列。


2. 客户端 connect 时，把本地 socket 状态设置成了 TCP_SYN_SENT，选则一个可用的端口，发出 SYN 握手请求并启动重传定时器。
3. 服务器响应客户端发出的 syn 时，会判断下接收队列是否满了，满的话会丢弃该请求。否则发出 syn ack，申请 request_sock 添加到半连接队列中，同时启动定时器。
4. 客户端响应 syn ack 时，清除了 connect 时设置的重传定时器，把当前 socket 状态设置为 ESTABLISHED，开启保活计时器后发出第三次握手的 ack 确认。
5. 服务器响应 ack 时，把对应半连接对象删除，创建了新的 sock 后加入到全连接队列中，最后将新连接状态设置为 ESTABLISHED。
6. accept 从已经建立好的全连接队列中取出一个 socket（FD） 返回给用户进程持有，利用该 socket 资源进行通信使用。
